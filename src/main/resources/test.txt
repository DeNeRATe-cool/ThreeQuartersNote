不条件的话呢它就跳转到某个地某个这个其他地方去了但如果说不跳转那它就应该顺序执行它应该去执行后面的这条指令那我就把这条指令放到这个延迟槽当中去那么这个后两种方式从这个目标跳转目标或者说是不跳转的位置去取指令放到延迟槽里面这样种方式呢其实就是读概率就是我这个分支其实就两种可能一种是跳转就是这里跳转的话它就执行这条指令还有一种呢就不跳转那不跳转的时候它应该执行这条指令那么我去把它放到延迟槽里边延迟槽分支延迟槽是一定会得到执行的就是它遇到分支指令的时候呢不会立刻跳转而是先把它后边这条槽里边的指令执行完毕之后再去调转那么这两种情况都是赌概率它是要结合这个动态分支预测来进行的你预测哪个分支的概率大你就去取这个地方的指令来执行那么最好的方式呢是第一种是从前边去取指令因为按照咱们程序运行的逻辑来说我要运行到这个分支的地方的时候那前边呢是已经是顺序执行过来那么前面的这条指令呢是毫无疑问它是必须得到执行的那么这种一定要运行的指令你把它放到这个延迟槽里边就是分支指令执行的时候这条指令呢也取进流水线里边来执行那是不会有任何错误的就本身一定会执行的指令你把它放到这里让它去运行那它不可能说是取错了回头要被废弃不会的所以这个工作是一定是有效的那么后边两种情况呢取进来的还是有一定的概率会被这个飞掉那我们看一下这个非延迟分支和延迟分支的它的这个一个运行情况的对比我们先看非延迟分支非延迟分支就是说一旦遇到BQ指令就按照它的这个判断结果去进行跳转跳转到这个跳转目标的这个指令上来那么我们看一下延迟分支对应的这个情况延迟分支呢我们这里呢是给它调整了一下这个指令顺序先不看这个我们先看延迟分支执行的这个它遇到这个B指令的时候不是说B指令执行完了立刻就跳转到下条指令跟这不一样这里是B指令执行然后就按照它的这个地址跳转那这个呢就是这里有一个延迟槽就B指令后续的这个延迟槽里的指令执行完之后才会去进行跳转所以我们叫延迟分支这个分支呢是延迟了一个指令等这个槽里边的指令全执行完了再跳转所以这是两个不一样的地方非延迟是遇到B指令然后立刻跳转延迟分支是遇到B指令之后把下一条槽里边的指令执行完毕再进行调整那么这里呢我们就用了我们刚才的这个最好的这个第一种的调度的情况就是我们这个看一下我们的这个非延迟分支这个BQ指令呢它是要用到这个S1和S4这两个寄存器当中的值呢去进行这个比较的所以呢你这个add和sub指令和BQ的指令它这个顺序呢你没有办法去改变所以我要从这个BQ前边去找一条指令来放到这个槽延迟槽当中的话那就只能取这个all指令这个all指令跟它们是没有这个数据上的相关的跟它们完全没有关系那这时候我就可以调整顺序把它放到这个延迟槽当中来也就是说我们原本呢按照这个非延迟分支我们首先应该执行all指令然后去执行后续的这个B指令那么all指令是肯定必须执行的那我们把它调整一下放到这里之后呢那延迟槽中的指令呢也是肯定会执行的所以说它运算的这个结果逻辑上是不会有影响的那但是呢可以确保这个BQ不会引起后边的这个暂停那么用了这样的这个延迟分支的方式编译器呢就会在编译的时候选择合适的指令最好呢是从前边获取一条这个合适的指令所以说我们这里为什么不考虑这个其他指令那么首先呢我们要从前边去获取是最优的然后呢我们还要考虑有没有这个数据相关的问题一定要是取过来之后呢放到这之后调整了顺序完了它的这个功能不受影响就一定是必须要满足这些条件才行然后我们再看一下这个借指令这个跳转指令那同样呢也需要这个延迟槽的这个设计对于借指令来说呢它的这个主要的这个功能它实际上比B指令更简单它不需要去进行这个数据比较它呢就直接进行这个新地址新PC的这个计算就可以了所以呢它同样也要用到这里的这个二阶段啊就是一码阶段里面增加了这个PC计算的这块的这个硬件那么它呢就是把它的这个D26位给它取出来然后再跟这个PC的这个高四位去进行一个组合拼出一个32位的这个新地址然后送回到这个PC去那么同样啊它也是在第二阶段能够获得这个新的PC啊指所以呢后续可能会被清空的那就只剩下一阶段的啊一条后续的指令啊正在处在取指阶段的这条指令有可能是需要被清空的那么它也就是跟这个B指令一样啊只需要一个延迟槽就可以了那如果说是需要清空的话呢给这个延迟槽里面清零啊放一个NOP那么同样的也可能用这个呃就是选取其他的这个指令放到延迟槽里面执行的情况啊用来优化程序那么咱们这个因为它这个时序上啊就介指令它的这个地址计算跟咱们刚才这个呃B指令最后的这个设计其实是同一个阶段啊都是在一码阶段实现啊所以同样它也是只要一个延迟槽就可以了然后呢因为咱们的这个实际的MIPS都是这个延迟跳转的啊那么对于这个介类的指令同样它也是延迟跳转啊就延迟槽里面的指令一定会执行那么对于咱们的这个介指令啊比如说JAL指令啊那么它呢是需要有一个这个endlink啊它是有一个返回的这个地址要保存那么这个返回地址呢我们放在这个寄存器当中啊那么它和非延迟跳转就不一样啊非延迟的话我们应该返回PC加4遇到这个要跳转的指令我们跳走了啊它呢现在是在这个地址是PC的地方啊那么它的下一条指令应该是PC加4的地方啊但是现在呢这个PC加4呢它是延迟槽了啊延迟槽里面的指令呢是肯定在跳转前执行的啊延迟跳转会等待PC加4这个槽里面指令执行完之后再跳转所以呢这时候我们要返回的时候必须返回PC加8啊之前PC加4已经执行过了就不需要再跳回来了啊跳到它的下一条指令PC加8处来继续执行那么这是加了这个延迟槽之后啊进行延迟跳转之后啊会遇到的情况啊这个如果说只是借指令那么没有返回的问题啊但是如果是JL指令那要注意它返回的位置不是返回到延迟槽之中而是返回到延迟槽的下一条指令最后呢是一些这个相当于是复习的这个小练习啊为下面的这个每一组这个指令选择一个比较合适的描述啊就给了我们这个四组不同的这个指令然后呢看看啊第一个呢是它本来呢就不需要任何的阻塞啊然后呢还有一个是啊那有了这个旁路转发之后呢就不需要阻塞啊然后最后一个呢是必须去阻塞那么我们这个一个一个的来看一下啊第一段代码第一段代码呢是一个LW指令啊然后后续呢跟了一条R指令那么这个当中是存在这个数据冒险啊存在这个数据相关的那么之前就分析过这样的情况啊其实已经分析过了LW呢是要等这个四阶段完了之后才能够有它的这个取出来的这个值然后呢紧按下它下一条指令呢是在这个同一时间段里边就需要用这个值了所以这个呢是来不及的那这种情况下呢是必须有这个阻塞啊必须暂停的那不管说有没有这个旁路的这个转发都需要暂停啊这是这个LW后续跟这个R指令的情况那只不过有没有旁路呢它暂停的时常不一样那如果说是有旁路的情况下就我们之前设计了这个两级旁路转发的时候那它呢还需要阻塞一个是融旧器然后如果说是没有旁路的情况下那它就需要阻塞两个式中周器就是说我们之前讲的不去设计旁路转发那就中间需要间隔两条指令才行所以需要去加两个闹谱我们再看这个第二个例子连续三条R指令然后呢这个第一条和第三条是有这个数据相关的中间间隔了一条指令那么这个情况呢我们之前其实也讨论过就是在没有旁路转发的情况下呢是需要等前面的指令呢这个写到寄存器当中之后然后后续的这个指令呢才能够读到这个寄存器里面的数值所以这个隔了一条指令的时候是不够的必须这个隔两条指令到这儿的时候那才能够来得及所以说我们对于这种情况呢那我们是需要有旁路转发才行所以呢是如果说有旁路转发的情况下呢就不需要暂停但是如果说没有的话我们是需要去暂停一个时中周期那么判断标准还是一样的就是如果说没有旁路的话呢它们之间是要间隔两个指令就可以要间隔两条指令那现在呢是只有一条所以我们还需要往里面插一个NOP需要去暂停一个时中周期那么反正就是没有旁路的情况下你其实不用考虑它究竟是LW指令还是这个R指令都是一样的这个情况然后这个没有旁路的时候都是中间需要间隔两个时中周期我们再看这个第三个那么这里呢是连续的五条而指令然后我们去仔细的看一下它里面的这个数据相关发现了只有这个第一条和第五条指令它是有这个数据相关那么这个五条指令的话第一条指令呢它在这个阶段就已经把这个结果保存到这个寄存器当中了然后这个第五条指令它的读寄存器是在它的时间上更后边的这个位置了所以说这种情况下你是这个完全没有问题的就是完全等这个第一条都执行完毕了然后这个第五条才会去读寄存器这个时间是非常充足的咱们之前说过我们这个当中呢只要间隔的有两条指令它其实就没有问题了那现在呢间隔了三条那就更没有问题了所以呢直接本身就不需要暂停然后第四第四个情况我们这个那这里就是我们说的这个本身是这个间隔了两条指令那么只要我们实现了在同一个时钟周期里边先去写寄存器前半周期写了然后后半个时钟周期呢就可以读出来可以同时在一个时钟周期里边对寄存器进行这个先写后读那么这个间隔了有两个指令然后这个也是没有问题的所以这个就是咱们去进行这个判断的时候你要看一看它是有旁路还是没有旁路有没有旁路的时候呢那么这当中的这个需不需要暂停这些情况都不一样另外就是说旁路它给你的设计是什么样的也很重要咱们通常在考试的时候都不会给你一个常规的设计不是按照咱们课上讲的我去设计的这个旁路可能会做一些这个其他的修改当然这修改可能也不合理它转发的时候它有可能是并不是说一个很好的合理的设计但是你要会判断具体的情况那么咱们这个前面是讲了这个流水线的设计以及呢讲了这个三种冒险的这个处理结构冒险数据冒险和这个控制冒险然后最后呢我们再来介绍这个CPU设计的最后一部分就是它的这个异常和中断的处理那么咱们这个计算机的这个运行当中经常会有一些意外的事件要求控制流改变这个不同的这个指令引擎呢可能会使用不同的方式所谓的这个控制流就是我们一个计算机呢它从启动开始然后呢一直到这个关机为止那么它呢这中间是有一条接着一条的指令不停的在这个运行当中的那么这个就是计算机的控制流那通常来说我们运行一个用户程序的时候我们认为这个计算机就按照我们这个汇编代码的顺序一条指令接着一条指令的执行但是有可能在我们这个执行到某一条这个当前指令的时候这时候呢计算机里面出现了一个这个意外事件就不是我们这个程序执行里边的这个事件它可能出了其他的这个问题比方说这个出现了一个这个硬件的错误或者说呢发现需要去进行一个这个IO的操作等等那这个意外的发生之后呢计算机实际上是需要由这个OS操作系统呢去对它去进行一个处理然后等这个意外事件处理完毕之后呢再返回到我们当前原来执行的这个进程咱们的这个用户程序那返回的时候也可能有不同的情况有可能会返回咱们原来正在执行的这条指令也有可能呢当前这个指令呢不执行了去执行返回到它的下一条指令还有可能呢是既然就可能出问题了那么这时候原来的程序呢没有办法执行下去了必须abot必须终止运行回不去了没法回来了这些都是有可能的那么我们这些这个异常意外的这些这个情况我们如果给它细分一下的话呢可以分为这个异常和中断两类那么我们这里的这个异常指的是在CPU内产生的就是CPU里边在执行指令执行指令的过程当中出现了一些意外的情况比如说发现这个指令里边的这个操作码是未定义的那比如说我们这个指令的前六位操作码我们MIPS都给它规定了这个六位比如说全零的时候它是R指令然后等于什么的时候是哪条指令那有可能万一出错了这个里面有未定义的操作码出现了那么这就是指令执行的时候发现的出的这个问题或者这个指令执行结果呢是溢出了或者说是发生了系统调用或者说是TLB没有命中等等都是执行指令的时候产生的异常情况那还有一种呢我们把它叫中断它来自这个外部的IO控制器比如说这个磁盘中断这个硬盘往这个CPU发一个中断来告诉这个CPU我这个数据传输完毕了这个跟CPU内部的指令的执行是没有关系的这个叫做这个中断那么这个异常和中断的概念在不同的资料里边它可能都用法不太一样在某些资料里边可能它用异常来概括所有的这些异常和中断也可能在某些资料里边呢它就用中断来代替来指代所有的异常和中断所以这个就是各种不同的说法都有大家了解一下那么在不牺牲性能的情况下呢要处理这些问题是很困难的那么在MIPS当中呢异常是由一个系统鞋处理器CP0来进行管理的也就是说咱们设计CPU的时候除了之前我们讲的要进行这个数据通路设计有这个控制单元的设计另外呢还要包括一块就是这个鞋处理器的设计那么这个鞋处理器那么其中就包含这个异常处理的这个功能它呢要保存引起异常或者中断的指令的PC也就是说这个是计算机运行到什么地方的时候出现了这个异常或者中断那么要把它呢这个保存在一个特定的寄存器叫做EPC当中那PC呢就是咱们的这个程序计数器地址然后E呢就是异常就是发生中断的这个地方我们把它呢保存进来然后呢还要保存那么这个异常的原因是什么原因是引起了这个异常那么MIPS里边呢专门有一个这个CAUSE计存器那么这个MIPS里边是用了其中的五位来代表这个引起异常的原因那么在某些简化的这个实现当中呢可能只需要一位比如说你这个模型机里边只需要这个有两种异常的处理那你就一位就行了那么然后呢这个异常是需要去进行处理的那么在计算机里边呢有这个异常处理程序代码用它呢去针对不同类型的异常去进行不同的处理那么这个代码呢会放在某一个固定地址处那么这个是要根据CPU的这个模式来确定不同模式呢它的这个处理的代码放的位置可能是不一样的那比方说MIPS它的这个32位模式下面根据它的异常或者是中段向量表所谓的这个异常中段向量表实际上呢就是针对某种类型的异常然后呢处理的代码放在什么地址处是这样一个对应关系的一个表格就是我引起异常的原因知道了之后呢就到这个表里面去查表查表呢就可以获得一个代码的地址然后呢去跳转到这个地址去执行程序就可以去处理当前这种类型的异常了所以这是我们的这个中段向量表这个常见的一个说法一般是咱们国内的这个教材上一般就说中段向量表实际上是把异常和中段都放在这个表里边就是原因然后对应的代码每种原因对应代码那比如说这个MIPS32位模式下面它如果是遇到了一个这个reset复位的这样一个中段或者是nmi就是不可屏蔽的中段通常这个不可屏蔽中段都是比较严重的硬件问题遇到这样的这个异常的时候呢它会跳到这个地址去执行这个处理然后这个tlbrefill这样一个异常的话也是到这个地址去然后如果是高速缓存的错误那么就到这个地址然后其他的异常呢都进这个地址去处理那么这个地方就是一个通用的异常处理的代码它的这个起始位置也就是说这些这个针对不同的中段类型确定往哪个地址去跳转去执行是由我们的这个中段向量表里边去规定的所以这也是一个很重要的这个内容这个异常中段向量表那发生这个异常的时候呢这个操作系统会被通知那么操作系统呢会针对这个情况去进行处理有可能呢这个发生了一个这个比较严重的错误比方说SACFORT断错误这个比方说你在这个内存访问里面发生了这个严重问题好咱们今天就先到这儿下节课咱们今天讲完老师问一下我问一下它这个它这个它都是跑路转的它这个是隔一条直径的转那应该是从这里从这里这个比如说我问你一想说它时序上没有问题在这儿它已经计算了结果了然后是在这儿有它的时间上就计算了嗯嗯也时序上没有问题嗯对就是还有就是它那个每个时序逻辑就是说它每次在这个中间这个寄存器都是有结果的然后只要中间有结果然后后面的这个阶段就会进行计算然后是等它那个时钟一到来之后说明它里面的寄存器被更新对对对就是就是时钟控制值它控制来写这个对对对对对对对那就是那个呃PC就是PC单元就是PC单元它一开始就是里面它这会纸上纸上一个代码然后那个时钟一来它写到这儿然后这个时候PC的结果其实它已经算好了放在这儿然后下一个星期一来之后它变成4对对对然后它变成4写在这儿之后立马就变成8对对对对哦对对对好谢谢老师谢谢老师